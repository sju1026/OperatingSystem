11장 CPU 스케줄링

* 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것
프로세스 우선순위
- 우선순위가 높은 프로세스 : 빨리 처리해야 하는 프로세스들 / 대표적으로 입출력 작업이 많은 프로세스
- 입출력 집중 프로세스 : 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스
- CPU집중 프로세스 : 복잡한 수학연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이  CPU 작업이 많은 프로세스

스케줄링 큐
- CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄세우는 것
* 준비큐 : CPU를 ㅇ용하고 싶은 프로세스들이 서는 줄 (준비상태)
* 대기 큐 : 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄 (대기상태)

선점형과 비선점형 스케줄링
- 선점형 스케줄링 : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 갖에로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
* 장점 : 어느 한 프로세스의 자원 독점을 막교 프로세스들에 골고루 자원을 배분 가능
* 단점 : 문맥교환과정에서 오버헤드가 발생할 수 있음
- 비선점형 스캐줄링 : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식
* 장점 : 문맥교환에서 발생하는 오버헤드는 적다
* 단점 : 하나의 프로세스가 자원을 사용중이라면 단장 자원을 사용해야하는 상황에서도 무작정 기다리는 수밖에 없다.

스케줄링 알고리즘
- FCFS (선입선처리 스케줄링) : 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링
- SJF (최단 작업 우선 스케줄링) : 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식 / 비선점형 스케줄링
- RR (라운드로빈 스케줄링) : 선입선처리 스케줄링에 타임슬라이스라는 개념이 더해진 스케줄링 방식 / 선점형 스케줄링
* 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미
- SRT (최소 잔여 시간 우선 스케줄링) : 최단 작업 우선 스케줄링 알고리즘과 라운드로빈알고리즘을 합친 스케줄링 방식 /
* 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택

우선순위 스케줄링 
* 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘
* 기아현상 : 우선순위가 높은 프로세들에 의해 실행이 계속 연기되는 현상
* 에이징 : 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
- 다단계 큐 스케줄링 : 우선순위별로 준비 큐를 여러 개 사용하는 스캐줄링
- 다단계 피드백 큐 스케줄링 : 다단계 큐 스케줄링과 비슷하게 작동하지만, 프로세스들이 큐 사이를 이동할 수 있다는 점이다
* CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고 CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝난다

12장 프로세스 동기화

동기화 : 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장하기 위한 것
* 작업들 사이의 수행시기를 맞추는 것
-> 프로세스 동기화 : 프로세스들 사이의 수행 시기를 맞추는 것
1. 실행 순서 제어를 위한 동기화
* 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것
2. 상호 배제를 위한 동기화
* 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘

생산자와 소비자 문제
* 물건을 계속 생산하는 프로세스인 생산자와 물건을 계속해서 소비하는 프로세스인 소비자로 이루어짐 -> 동시에 접근해서는 안되는 자원에 대한 예제
- 공유자원 : 동시에 실행되는 프로세스들의 공동의 자원 / 전역변수, 파일, 입출력장치, 보조기억장치 등이 가능 
* 공유자원 중에는 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원이 있다 -> 접근하는 코드 영역 : 임계구역
- 임계구역 : 두 개 이상의 프로세스가 동시에 실해오디면 안되는 영역
- 레이스 컨디션 : 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계구역의 코드를 실행하여 문제가 발생하는 경우

동기화 기법
- 뮤텍스 락 : 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구, 다시말해 상호 배제를 위한 동기화 기구 (하나의 공유자원에 접근하는 프로세스를 상정)
* acquire 함수 : 프록세스가 임계구역에 진입하기 전에 호출하는 함수
* release 함수 : 임계구역에서의 작업이 끝나고 호출하는 함수
* 바쁜 대기 : 뮤텍스 락이 잠겨있는지 쉴새없이 반복하며 확인해 보는 것

- 세마포 : 공유자원이 여러개 있는 상황에서도 적용이 가능한 동기화 도구 
* 이진 세마포와 카운팅 세마포로 구분 : 이진세마포는 뮤텍스락과 유사한 개념
* 멈춤신호와 가도좋다는 신호로 임계구역을 관리한다 / 프로세스는 임계구역 앞에 멈춤신호를 받으면 잠시 기다리고, 가도 좋다는신호를 바등면 그제서야 임계구역에 들어가게 된다.
* wait 함수 / singnal 함수

- 모니터 : 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리한다 / 프로세스는 반드시 인터페이스를 통해서만 공유자원에 접근이 가능하다
* 이를 위해 모니터를 통해 공유자원에 접근하고자 하는 프로세스를 큐에 삽입하고 큐에 삽입된 순서대로 하나씩 공유자원을 이용하도록 한다
* 모니터는 공유자원을 다루는 인터페이스에 접근하기위한 큐(모니터에 진입하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다
* 조건변수 : 프로세스나 스레드의 실행순서를 제어하기 위해 사용하는 특별한 변수

13장 교착상태

식사하는 철학자 문제
- 교착상태 : 일어나지 않을 사건을 기다리며 진행이 멈춰버리는 현상
자원할당 그래프 : 어떤 프로세스가 자원을 사용하고 있고, 또 어떤 프로세스가 어떤 자원을 기다리고 있는지를 표현하는 간단한 그래프
1. 프로세스는 원으로 자원의 종류는 사가곃ㅇ으로 표현
2. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현
3. 프로세스가 어떤 자원을 할당받아 사용장우리면 자원에서 프로세스를 향해 화살표를 표시
4. 프로세스가 어떤 자원을 기다리고 있다면 프로세에서 자원으로 화살표를 표시
교착상태 발생 조건 : 상호 배제, 점유와 대기, 비선점, 원형 대기
- 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때
- 점유와 대기 : 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태
- 비선점 : 자원을 이용하는 프로세스의 작업이 끝나야만 비로소 이용 가능 / 어떤 프로세스도 다른 프로세스의 자원을 갖에로 빼앗지 못하기 때문
- 원형 대기 : 자원 할당 그래프가 원의 형태로 자원을 대기하는 것

교착상태 해결방법
- 예방 / 회피 / 검출 / 회복
교착상태 예방
- 교착상태 발생 조건을 하나씩 예방
* 상호 배제 예방 : 모든 자원을 공유 가능하게 만든다
> 단점 : 한 자원을 동시에 두 프로세스 혹은 다수의 프로세스가 사용 -> 현실적으로 무리
* 점유와 대기 예방 : 철학자들로 하여금 한 손에 포크를 들고 다른 포크를 기다리지 못하게 금지
> 자원 활용률이 낮음
* 비선점 조건 예방 : 자원을 이용중인 프로세스로부터 해당 자원을 빼앗을 수 있다
> 범용성이 떨어진다
* 원형 대기 조건 예방 : 모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당
> 모든 컴퓨터 시스템 내에 존재하는 수많은 자운에 번호를 붙이는 일은 간단한 작업이 아니거니와 각 자원에 어떤 번호를 붙이는지에 따라 특정 자원의 활용률이 떨어짐
교착상태 회피 
- 교착상태가 발생하지 않을 정도로 조심조심 자원을 할당하는 방식
* 안전상태 : 교착상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태
* 불안정 상태 : 교착상태가 발생할 수도 있는 상황
* 안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
교착상태 검출 후 회복
- 교착상태 발생을 인정하고 사후 조치하는 방식
* 선점을 통한 회복 : 교착상태가 해결될 때까지 한 프로세스 씩 자원을 몰아주는 방식
* 프로세스 강제 종료를 통한 회복 
> 교착상태에 놓인 프로세스를 모두 강제종료 -> 프로세스들의 작업 내역을 읽게 될 가능성
> 교착상태가 없어질 때까지 한 프로세스씩 강제 종료 -> 작업 내역을 잃은 프로세스는 최대한 줄일 수 있지만 교착상태가 없어졌는지 여부를 확인하는 과정에 오버헤드 야기

14장 가상 메모리

연속 메모리 할당
- 프로세스에 연속적인 메모리 공간을 할당하는 방식

스와핑
- 메모리에 적재된 프로세스들 중에는 현재 실행되지 않는  프로세스가 있을 수 있다
- 이러한 프로세스들은 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또는 다른 프로세스를 적재하여 실행하는 방식
* 스왑 영역 : 프로세스들이 쫒겨나는 보조기억장치의 일부 영역
* 스왑 아웃 : 현재 실행되지 않는 프로세스가 메로리에서 스왑영역으로 옮거지는 것
* 스왑 인 : 스왑영역에 있던 프로세스가 다시 메모리로 옮겨지는 것

메모리 적합
- 최초 적합 : 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
- 최적 적합 : 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치
- 최악 적합 : 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식
외부 단편화
-프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 의미
- 메모리를 압축 : 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈공간으로 만드는 방법

페이징을 통한 가상메모리 관리
- 가상메모리 : 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
-> 페이징 / 세그먼트
- 페이징 : 메모리의 물리 주소 공간을 프레임단위로 자르고 프로세스의 논리주소공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
* 스왑아웃 - 페이지 아웃 / 스왑인 - 페이지 인
페이지 테이블
- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표 / 페이지 번호를 이용해 페이지가 적재된 프레임을 찾을 수 있다

내부 단편화
- 하나의 페이지 크기보다 작은 크기로 발생한다
페이지테이블베이스레지스터(PTBR) : CPU내의 각 프로세스의 페이지 테이블이 적재된 주소
- TLB 히트 : CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우
- TLB 미스 : 페이지 번호가 TLB에 없을 경우 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 것
페이징 주소 변환
- 모든 논리주소 : 페이지 번호와 변위로 이루어짐
- 논리주소 <페이지 번호, 변위> 는 물리주소 <프레임 번호, 변위>로 변환
페이지 테이블 엔트리
- 페이지 테이블의 각각의 행
* 유효비트 : 현재 해당 페이지에 접근 가능한지 여부 / 페이지 테이블 엔트리에서 프레임 번호 다음으로 중요한 정보
* 페이지 폴트 : CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하는경우 발생하는 예외
* 보호 비트 : 페이지 보호 기능을 위해 존재하는 비트 / 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타냄
* 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부
* 수정비트(더티비트) : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부
- 계층적 페이징 : 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식 / 다단계 페이지 테이블 기법(여러 단계의 페이지를 둔다는 점)이라고도 부른다

페이지 교체와 프레임 할당
- 요구페이징 : 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
1. CPU가 특정 페이지에 접근하는 명령어를 실행한다
2. 해당 페이지가 현재 메모리에 있을 경우(유효비트가 1일경우) CPU는 페이지가 적재된 프레임에 접근한다
3. 해당 페이지가 현재 메모리에 없을 경우(유효비트가 0일 경우) 페이지 폴트가 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다
5. 다시 1번을 실행한다
- 순수 요구 페이징 : 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행부터 할 수도 있는경우 / 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고 실행에 필요한 페이지가 어느정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다
- 페이지 교체 알고리즘 : 당장 실행에 필요한 페이지를 적재 -> 적재된 페이지를 보조기억장치로 보낸다 이때 최선의 페이지를 찾는 것과 결정하는 것
* FIFO 페이지 교체 알고리즘 : 메모리에 가장 먼저 올라온 페이지부터 내쫒는 방식
* 최적 페이지 교체 알고리즘 : CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘 / 앞으로의 사용빈도가 가장 낮은 페이지를 교체하는 알고리즘
* LRU 페이지 교체 알고리즘 : 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어로 만들어진 알고리즘 / 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

스레싱과 프레임 할당
- 페이지 폴트 : 나쁜 페이지 교체 알고리즘 / 프로세스가 사용할 수 있는 프레임 수가 적은 경우
- 스레싱 : 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
- 멀티프로그래밍의 정도 : 메모리에서 동시에 실행되는 프로세스의 수
프레임 할당 방식
정적 할당 방식 : 균등할당, 비례할당 / 동적 할당 방식 : 작업 집합 모델, 페이지 폴드 빈도
- 균등할당 : 모든 프로세스에 균등하게 프레임을 제공하는 방식
- 비례할당 : 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식
- 작업 집합 모델 기반 프레임 할당 : 작업 집합의 크기만큼만 프레임을 할당하는 방식
- 페이지 폴트율 기반 프레임 할당 : 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식

15장 파일 시스템

파일과 디렉터리
- 파일 : 하드디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합 
* 부가 정보 : 속성 또는 메타데이터
파일 연산을 위한 시스템 호출 => 운영체제에 의해 모든 파일 생성
- 파일 생성 -> 삭제 -> 열기 -> 닫기 -> 읽기 -> 쓰기 등
디렉터리 : 폴더
- 트리구조 디렉터리 : 여러 계층으로 파일 및 폴더를 관리
* 최상위 디렉터리(루트 디렉터리, /), 서브 디렉터리(윈도우 운영체제 : C:\)
* 경로
> 디렉터리를 이용해 파일/ 디렉터리의 위치, 나아가 이름까지 특정지을 수 있는 정보
> 절대 경로와 상대 경로
* 절대경로 : 루트 디렉터리에서 자기 자신까지 이르는 고유한 경로
* 상대 경로 : 현재 디렉터리에서 자기 자신까지 이르는 경로
> 같은 디렉터리에는 동일한 이름의 파일이 존재할 수 없지만, 서로 다른 디렉터리에는 동일한 이름의 파일이 존재할 수 있음
* 디렉터리 엔트리
> 사실 많은 운영체제에서는 디렉터리를 그저 '특별한 형태의 파일'로 간주 즉, 디렉터리는 그저 '포함된 정보가 조금 특별한 파일'
> 파일의 내부에는 파일과 관련된 정보들이 있다면, 디렉터리의 내부에는 해당 디렉터리에 담겨있는 대상과 관련된 정보들이 담겨있다 -> 이 정보는 보통 테이블 형태로 구성
* 각 엔트리에 담기는 정보 : 디렉터리에 포함된 대상의 이름, 그 대상이 보조기억장치 내에 저장된 위치(를 유추할 수 있는 정보)

파일시스템
- FAT 파일시스템과 유닉스 파일시스템 
- 파티셔닝과 포메팅
* 파티셔닝 : 보조기억 장치를 사용하기 위해 파티션을 나누는 작업 / 포멧팅 : 포멧작업
* 파티셔닝 : 저장장치의 논리적인 영역을 구획하는 작업 / 각 영역은 파티션
* 포매팅 : 저장 장치를 완전히 삭제하는 것으로 알고 있는 사람들이 많지만, 사실 이는 완벽하게 정확하지 않다. 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 준비를 하는 작업
> 저수준 포매팅 : 저장 장치를 생성할 당시 공장에서 수행되는 물리적인 포매팅
> 논리적 포매팅 : 파일 시스템을 생성하는 포매팅
* USB 메모리를 포매팅 할 때 파일시스템이 결정된다
파일 할당 방법
- 연속할당 : 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식
* 구현이 단순하지만 외부단편화를 야기한다
- 불연속 할당
* 연결할당 : 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식, 즉, 파일을 이루는 데이터를 연결 리스트로 관리
> 불연속 할당의 일종이기 때문에 파일이 여러 블록에 흩어져 저장되어도 무방하다
> 외부 단편화 문제를 해결하지만 단점이 존재
1. 반드시 첫 번째 블록 부터 하나씩 차례대로 읽어야 한다
2. 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다
* 색인할당 : 파일의 모든 블록 주소를 색인블록이라는 하나의 블록에 모아 관리하는 방식

파일 시스템 살펴보기
FAT 파일 시스템 : FAT를 이용하는 파일 시스템
- 파일 할당 테이블(FAT: File Allocation Table) : 각 블록에 포함된 다음 블록의 주소들을 한데 모아 테이블 형태로 관리하면서 앞서 언급한 단점을 상당 부분 해소
* FAT 뒤에 오는 숫자는 블록을 표현하는 비트 수 (윈도우에서는 '블록'이라는 용어 대신 클러스터라는 용어를 사용)
유닉스 파일 시스템 : 색인 할당의 색인 블록을 i-node(index-node)라고 부르며 i-node에는 파일 속성 정보와 열다섯개의 블록 주소를 저장 -> FAT처럼 i-node에 파일속성 정보 표현
- i-node 하나만으로는 파일의 데이터 블록을 모두 가리킬 수 없는 문제를 해결하는 방법
1. 블록 주소 중 열 두개에는 직접 블록 주소를 저장
2. 1의 내용으로 충분하지 않다면 열세번째 주소에 단일 간접 블록 주소를 저장
3. 2내용으로 충분하지 않다면 열네 번째 주소에 이중 간접 블록 주소를 저장
4. 3내용으로 충분하지 않다면 열다섯 번째 주소에 삼중간접 블록 주소를 저장
NT 파일시스템 : 윈도우 운영체제
ext 파일 시스템 : 리눅스 운영체제

저널링 파일 시스템
- 저널링 기법 : 작업 로그를 통해 시스템 크래시가 발생했을 때 빠르게 복구하기 위한 방법
1. 작업 직전 파티션의 로그 영역에 수행하는 작업(변경 사항)에 대한 로그를 남긴다
2. 로그를 남긴 후 작업을 수행한다
3. 작업이 끝났다면 로그를 삭제한다
마운트 : 연결