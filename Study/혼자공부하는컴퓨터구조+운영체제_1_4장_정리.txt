2장 데이터

가장 작은 정보 단위 : bit = n -> 2^n개의 정보 표시 가능
8개의 bit = byte = 256개의 정보 표현 -> KB -> MB -> GB -> TB

이진수 : ob1000, 1000(2) = 8 - 이진수 표기법
0과 1만으로 음수를 표현하는 방법 중 가장 많이 사용 : 2의 보수(two's complement)
- 보수 : 어떤 수를 그보다 큰 2^n에서 뺀 값 = 간닪나 표현 : 모든 0과 1을 뒤집고 거기에 1을 더한 값
* 하지만 이렇게만 작성할 경우 양수와 음수 구분 불가 -> flag를 사용
* flag - 부가정보
* 보수의 한계 : 2^n 또는 0은 보수로 표현이 불가

16진수 : 15(16), ox15
- 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F -> 10 으로 표현

0과 1로 문자를 표현
문자 집합과 인코딩
- 문자집합 : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩 : 문자집합의 문자를 0과 1로 변환 / 문자 디코딩 : 0과 1로 이루어진 문자코드를 사람이 이해할 수 있는 문자로 변환하는 과정
아스키 코드
- 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자 그리고 일부 특수문자를 포함
* Space : 32 / 0 : 48 / A : 65 / a : 97 -> 아스키 코드 : 아스키 문자에 대응된 고유한 수
* 훗날 더 다양한 문자표현을 위해 아스키 코드에 1비트를 추가한 8비트의 확장 아스키도 등장
** 한글 인코딩 방식 : EUC-KR
> 완성형 인코딩 : 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여
> 조합형 인코딩 : 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식
>> 한글 한 글자에 2바이트 코드가 부여 -> 한 글자 표현시 16비트가 필요 -> 4자리의 십육진수로 표현

** 유니코드 : EUC-KR보다 훨씬 다양한 한글을 포함하며 대부분 나라의 문자, 특수문자, 화살표나 이모티콘까지도 코드로 표현할 수 있는 통일된 문자집합
> 유니코드 인코딩 방식 : UTF-8, 16, 32 등 : 유니코드 문자에 부여된 값을 인코딩하는 방식

3장 명령어

고급언어 : 사람을 위한 언어 / 저급언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
저급언어 -> 명령어
- 기계어 : 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어 : 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급언어 : 이를 코딩할 때 직접적으로 사용하기도 한다
고급언어 -> 저급언어 변환
- 컴파일 : 컴파일러에 의해 소스코드 전체가 저급언어로 변환되어 실행되는 고급언어 : 변환된 코드 = 목적코드
* 오류가 하나라도 존재할 경우 전체 저급언어 변환 불가
* test.c -> 전처리기(preprocessor) -> 컴파일러(compiler) -> 어셈블러(assembler) -> 링커(linker) -> test.exe
** 전처리기 (.i)
> 본격적으로 컴파일하기 전에 처리할 작업들
> 외부에 선언된 다양한 소스코드, 라이브러리 포함 (#inlcude)
> 프로그래밍의 편의를 위해 작성된 매크로 변환 (#define)
> 컴파일할 영역 명시 (#if, #ifdef, ...)
** 컴파일과정 (.s)
> 전처리가 완료 되어도 여전히 소스코드
> 전처리 완료된 소스코드를 저급언어(어셈블리언어)로 변환
** 어셈블 과정 (.o)
> 어셈블리어를 기계어로 변환
> 목적코드(object file)를 포함하는 목적 파일이 됨
** 링킹
> 각기 다른 목적코드를 하나의 실행파일로 묶어주는 작업

- 인터프리터 : 인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급언어
* 오류가 있을경우 n-1번째 줄까지 저급언어로 변환
- 목적파일 : 목적코드로 이루어진 파일 / 실행파일 : 실해오드로 이루어진 파일 = ex).exe
* 목적 코드가 실행파일이 되기 위해서는 링킹이라는 작업 필요
** 링킹 : main.o에 없는 기능을 연결 짓는 작업

연산코드와 오퍼랜드
- 연산코드(operation code) : 명령어가 수행할 연산(연산자) / 오퍼랜드(operand) : 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치(피연산자)
* 연산 코드가 담기는 영역 : 연산코드필드 / 오퍼랜드가 담기는 영역 : 오퍼랜드 필드
오퍼랜드
- 오퍼랜드 필드 = 주소필드
* 숫자와 문자 등을 나타내는 데이터 또는 주로 메모리나 레지스터 주소가 온다
* 오퍼랜드가 없는 경우 = 0-주소 명령어
연산코드
* 데이터 전송 : MOVE / STORE / LOAD(FETCH) / PUSH / POP
* 산술/논리 연산 : ADD / SUBTRACT / MULTIPLY / DIVIDE / INCREMENT / DECREMENT / AND / OR / NOT:AND / OR / NOT / COMPARE
* 제어 흐름 변경 : JUMP / CONDITIONAL JUMP / HALT / CALL / RETURN
* 입출력 제어 : READ(INPUT) / WRITE(OUTPUT) / START IO / TEST IO

주소지정방식
- 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도만 가능. 즉 2^6개의 정보의 가짓수
-> 이를 보완하기 위해 주소정보를 사용
* 유효주소 : 연산의 대상이 되는 데이터가 저장된 위치
* 주소지정방식 : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법 (오퍼랜드 필드에 명시하는 값)
** 즉시 주소 지정 방식 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식 (연산에 사용할 데이터)
** 직접 주소 지정 방식 : 오프랜드 필드에 유효주소를 직접적으로 명시하는 방식 (유효주소(메모리 주소))
** 간접 주소 지정 방식 : 유효주소의 주소를 오퍼랜드 필드에 명시 (유효주소의 주소)
** 레지스터 주소 지정 방식 : 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시 (유효 주소(레지스터 이름))
** 레지스터 간접 주소 방식 : 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시 (유효주소를 저장한 레지스터)
** 스택 주소 지정 방식 : 스택과 스택포인터를 이용한 주조 시정 방식
> 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터, 즉, 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
** 변위 주소 지정방식 : 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효주소를 얻어내는 주소 지정 방식
> 상대 주소 지정 방식 : 오퍼랜드와 프로그램 카운터의 값을 더하여 유효주소를 얻는 방식 
> 베이스레지스터 주소 지정 방식 : 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식 / 베이스레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효주소를 얻어내는 방식
>> 베이스 레지스터 : '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할

4장 CPU의 작동 원리

- ALU : 연산한 결괏값과 플래그를 내보낸다
* 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들인다
* 레지스터와 제어장치로 부터 받아들인 피연산자와 제어신호로 산술연산, 논리연산 등 다양한 연산을 수행
* 연산결과는 일시적으로 레지스터에 저장-> 실행속도 저하 방지 (연산 결과에는 flag가 포함)
** flag의 종류 -> 이들은 플래그 레지스터에 저장
> 부호 플래그 : 연산한 결과의 부호를 나타낸다
> 제로 플래그 : 연산 결과가 0인지 여부를 나타낸다
> 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지를 나타낸다
> 오버플로우 플래그 : 오버플로우가 발생했는지를 나타낸다
> 인터럽트 플래그 : 인터럽트가 가능한지를 나타낸다
> 슈퍼바이저 플래그 : 커널모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다

- 제어장치 : 제어신호를 내보내고, 명령어를 해석하는 부품
* 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호 / CPU의 구성 요소 중 가장 정교하게 설계된 부품
* 제어장치가 받아들이는 정보
> 클럭신호 : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
> 해석해야 할 명령어 : 명령어 레지스터에 저장된 CPU가 해석해야 할 명령어
> 플래그 레지스터 속 플래그 값 : ALU연산에 대한 추가적인상태 정보
> 시스템 버스, 그 중에서 제어 버스로 전달된 제어신호 : CPU 외부 장치가 발생시킨 제어신호
* 제어 장치가 내보내는 정보
> CPU 외부에 전달하는 제어신호 : 제어버스로 제어신호를 내보낸다
>> 메모리에 전달하는 제어신호 : 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰는 경우
>> 입출력 장치에 전달하는 제어신호 : 입출력장치의 값을 읽거나 입출력 장치에새로운 값을 쓰는 경우
> CPU 내부에 전달하는 제어신호
>> ALU에 전달하는 제어신호 : 수행할 연산을 지시하기 위해
>> 레지스터에 전달하는 제어신호 : 레지스터간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해

- 레지스터의 역할
* 프로그램 카운터(명령어 포인터) : 메모리에 가져올 명령어의 주소 즉 메모리에서 읽어 들일 명령어의 주소를 저장 / 프로그램 카운터의 경우 메모리 버퍼 레지스터에 값이 할당되면 카운트 1 증가 (다음 명령어 처리를 위해)
* 명령어 레지스터 : 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
* 메모리 주소 레지스터 : 메모리의 주소를 저장하는 레지스터
* 메모리 버퍼 레지스터 : 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터
* 범용 레지스터 : 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터 / 데이터와 주소 모두 저장가능
* 플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터
* 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터, 즉, 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
* 베이스 레지스터 : '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'로서의 역할

명령어 사이클
- 명령어 사이클 : 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는 주기
- 인출 사이클 : 메모리에 있는 명령어를 CPU로 가져오는 단계
- 실행사이클 : CPU로 가져온 명령어를 실행하는 단계
- 간접사이클 : 명령어를 실행하기 위해서 메모리에 접근을 한번 더 실행하는 것

인터럽트
- CPU의 작업을 방해하는 신호 - 중단 등
* 동기 인터럽트 : CPU에 의해 발생하는 인터럽트 (예외 : CPU가 실행하는 프로그림ㅇ상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생)
* 비동기 인터럽트(하드웨어 인터럽트) : 주로 입출력장치에 의해 발생하는 인터럽트로 알림과 같은 알림역할을 수행
> CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 이런 알림과 같은 하드웨어 인터럽트를 사용
** 처리순서
1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개
- 인터럽트 요청 신호 : 실행 흐름을 끊기 전 여부 확인
* 막을 수 있는 인터럽트 / 막을 수 없는 인터럽트 : 인터럽트 플레그에 의해 결정
- 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
- 인터럽트 서비스 루틴(인터럽트 핸들러) : 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램 
- 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작주소를 포함하는 인터럽트 서비스 루틴의 식별 정보

예외의 종류
- 폴트 : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
- 트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외 -> 디버깅(프로그램 개발 중에 발생한 문제를 진단하고 해결하기 위한 작업)
- 중단 : CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트 : 시스템 호출이 발생했을 때 나타난다