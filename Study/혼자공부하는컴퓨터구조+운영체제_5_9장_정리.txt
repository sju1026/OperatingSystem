5장 CPU 성능 향상 기법

- 코어 : 명령어를 실행하는 부품
* CPU : 명령어를 실행하는 부품을 여러개 포함하는 부품 = 멀티코어CPU 또는 멀티코어 프로세서
* 중요한 것 : 코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐
- 스레드 : 실행 흐름의 단위
-> 하나의 코어로 여러 명령어를 동시에 처리하는 CPU = 멀티스레드 프로세서 또는 멀티스레드 CPU
* 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
* 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위 
- 멀티코어 프로세서 : 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU
- 멀티스레드 프로세서 : 하나의 코어로 여러개의 명령어를 동시에 실행할 수 있는 CPU

명령어 파이프라인
- 명령어 인출 -> 명령어 해석 -> 명령어 실행 -> 결과 저장
* 명령어 파이프라이닝 : 명령어 파이프라인에 넣고 동시에 처리하는 기법
- 파이프라인 위험
* 데이터 위험 : 명령어 간 데이터 의존성에 의해 발생 
* 제어 위험 : 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생 / 분기예측 : 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술
* 구조적 위험 : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생
- 슈퍼스칼라 : CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
- 비순차적 명령어 처리(OoOE)
* 명령어들을 순차적으로 실행하지 않는 기법
* 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법

CISC와 RISC - ISA기반 CPU의 언어
- ISA : CPU가 이해할 수 있는 명령어들의 모음
- CISC : Complex Instruction Set Computer : 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
* 장점 : 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양하다 : 가변길이 명령어 활용
* 단점 : 활용하는 명령어가 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 샐행되기까지의 시간이 일정하지 않다 / 복잡한 명령어 때문에 명령어 하나르 ㄹ실행하는 데에 여러 클럭 주기를 필요로 한다
- RISC : Reduced Instruction Set Computer
* CISC에 비해 명령어의 종류가 적으며 CISC와는 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다. => 고정 길이 명령어
* 메모리 접근을 단순화, 최소화 하는 대신 레지스터를 적극적으로 활용

6장 메모리와 캐시 메모리

- RAM의 특징
* 휘발성 저장 장치 / 비휘발성 저장장치(SSD, CD-ROM, USB)
* CPU는 보조기억장치에 직접 접근을 못하므로 일반적으로 보조기억장치인 비휘발성 저장 장치에 보관할 대상을 저장하고 휘발성 저장 장치인 RAM에는 실행할 대상을 저장
* CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 이를 RAM으로 복사하여 저장한 뒤 실행
- RAM의 용량과 성능 : 클수록 많은 프로그램들을 동시에 빠르게 실행하는데 유리
- RAM의 종류
* DRAM(Dynamic RAM) : 저장된 데이터가 동적으로 변하는 RAM / 시간이 지나면 저장된 데이터가 점차 사라지는 RAM = 주기적으로 데이터 재활성화
* SRAM(Static RAM) : 저장된 데이터가 변하지 않는 RAM
* SDRAM(Synchronous Dynamic RAM) : 클럭신호와 동기화된 발전된 형태의 DRAM
* DDR SDRAM(Double Data Rate SDRAM) : 대역폭을 넓혀 속도를 빠르게 만든 SDRAM

- 메모리의 주소공간
* 물리 주소와 논리 주소
> 물리주소 : 정보가 실제로 저장된 하드웨어상의 주소
> 논리 주소 : 실행 중인 프로그램 각각에 부여된 0번지 부터 시작되는 주소 / 프로그램의 시작점으로 부터 떨어진 거리
-> 논리주소와 물리주소 간의 변호나은 CPU와 주소버스사이에 위치한 메모리 관리 장치(MMU: Memory Management Unit)
* CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환
* 베이스 레지스터 : 프로그램의 가장 작은 물리주소 즉 프로그램의 첫 물리주소를 저장하는 셈
- 메모리 보호 기법
* 한계 레지스터 : 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소범위를 벗어나는 명령어 실행을 방지하고 실행중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호할 방법 -> 실행중인 프로그램의 논리 주소의 최대 크기를 저장

- 저장장치 계층구조
* CPU에 얼마나 가까운가를 기준으로 계층적으로 나타낸 구조
- 캐시메모리 : CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장장치
* 가까운 순서로 L1, L2, L3캐시라고 부름
- 참조 지역성 원리
* 캐시메모리는 CPU가 사용할 법한 대상을 예츠가여 저장
* 캐시히트 : 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우
* 캐시미스 : 자주 사용될 것으로 예측하여 캐시메모리에 저장했지만 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우
* 캐시 적중률 : 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
* 캐시 메모리의 원칙 = 참조 지역성의 원리
1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다
- 공간 지역성 : 접근한 메모리 공간 근처를 접근하려는 경향

7장 보조기억장치

- 하드디스크 (자기 디스크)
* 자기적인 방식으로 데이터를 저장하는 보조기억장치
* 플래터 : 데이터가 저장되는 곳
> 트랙 / 섹터로 구성
> 실린더 : 같은 트랙의 모임
* 스핀들 : 플래터를 회전시키는 구성요소
* RPM : 스핀들이 플래터를 돌리는 속도(분당 회전 수)
* 헤드 : 플래터를 대상으로 데이터를 읽고 쓰는 구성 요소 / 디스크 암에 부착
* 탐색시간 : 접근하려는 데이터가 저자오딘 트랙까지 헤드를 이동시키는 시간
- 플래시 메모리 (USB, SD, SSD)
* 셀 : 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
> SLC타입 : 한 셀에 1비트를 저장할 수 있는 플래시 메모리
> MLC타입 : 한 셀에 2비트를 저장할 수 있는 플래시메모리
> TLC타입 : 한 셀에 3비트를 저장할 수 있는 플래시 메모리
* 페이지 : 셀들이 모여 만들어진 단위 -> 블록 : 페이지가 모여 만들어진 단위 -> 플레인 -> 다이
* 페이지의 상태
> Free상태 : 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태
> Valid 상태 : 이미 유효한 데이터를 저장하고 있는 상태
> Invalid 상태 : 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하고 있는 상태

- RAID의 정의와 종류
- RAID(Redundant Array of Independent Disks)의 정의
* 하드디스크와 SSD를 사용하는 기술로, 데이터의 안전성 혹슨 높은 성능을 위해 여러개의 물리적인 보조기억장치를 마치 하나의 논리적 보조기억장치철험 사용하는 기술
- RAID의 종류
* RAID 레벨 : 0, 1, 2, 3, 4, 5, 6, 10, 50 = 대중적 : 0, 1, 4, 5, 6
> RAID 0 : 여러개ㅡ이 보조기억장치에 데이터를 단순히 나누어 저장하는 구성방식
>> 스트라입 : 분산되어 저장된 데이터 / 스트라이핑 : 분산하여 저장하는 것
> RAID 1 : 복사본을 만드는 방식
> RAID 4 : RAID 1처럼 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장한 장치 => 병목현상
>> 패리티비트 : 오류를 검출하고 복구하기 위한 정보
> RAID 5 : 패리티 정보를 분산하여 저장하는 방식
> RAID 6 : 서로 다른 두 개의 패리티를 두는 방식

8장 입출력장치

- 장치컨트롤러 (입출력제어기 / 입출력 모듈)
* 문제점 : 종류가 너무나 많다 / 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮다
* 전송률 : 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표
* 컴퓨터에 직접 연결되지 않고 하드웨어를 통해 입출력장치를 연결하는 컨트롤러
** 문제 정리 : CPU와 입출력장치 간의 통신 중개 / 오류 검출 / 데이터 버퍼링
> 데이터 버퍼링 : 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법
* 데이터 레지스터 : CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
* 상태 레지스터 : 입출력장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지 , 입출력 장치에 오류는 없는지 등의 상태정보 저장
* 제어 레지스터 : 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장
- 장치 드라이버
* 장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

- 입출력 방법 : 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력
* 프로그램 입출력 : 프로그램 속 명령어로 입출력장치를 제어하는 방법 / CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력 장치에 연결된 저장 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
> 메모리 맵 입출력 : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
> 고립형 입출력 : 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
* 인터럽트 기반 입출력
** 풀링 : 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지를 주기적으로 확인하는 방식
** NMI : 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트
** 프로그래머블 인터럽트 컨트롤러 : 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지 알려주는 장치
* DMA 입출력 : 입출력장치와 메모리가 CPUㄹ르 거치지 않고도 상호작용 할 수 있는 입출력방식 = DMA = 직접 메모리에 접근할 수 있는 입출력 기능
> 입출력 버스 : 입출력 장치와 컴퓨터 내부를 연결짓는 통로로, 입출력 작업 과정에서 시스템 버스 사용 횟수를 줄여준다

9장 운영체제 시작하기

- 운영체제 : 실생할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램
* 커널영역 / 사용자 영역
* 응용프로그램 : 사용자가 특정 목적을 위해 사용하는 일반적인 프로그램
* 운영체제를 알아야 하는 이유
> 개발자는 하드웨어를 조작하는 코드를 직접 작성할 필요가 없어졌다
> 운영체제와의 대화로 하드웨어와 프로그램을 더 깊이 이해하고 문제 해결의 실마리를 찾을 수 있다.

- 커널
* 운영체제의 핵심 서비스를 담당하는 부분 : 자원에 접근하고 조작하는 기능, 프로그램이 올바르고 안전하게 실행되게 하는 기능 등
* 운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스
> 사용자 인터페이스 : 윈도우의 바탕화면과 같이 사용자가 컴퓨터와 상호작용 할 수 있는 통로 ex)GUI, CLI
- 이중모드와 시스템 호출
* 이중모드 : CPU가 명령어를 실행하는 모드를 크게 사용자모드와 커널모드로 구분하는 방식
* 사용자 모드 : 운영체제 서비스를 제공받을 수 없는 실행모드
* 커널모드 : 운영체제 서비스를 제공받을 수 있는 실행모드
* 시스템 호출 : 운영체제 서비스를 제공받기위한 요청 (사용자영역 -> 커널영역)

- 운영체제 핵심 서비스
* 프로세스 관리
* 자원 접근 및 할당
> CPU : CPU 스케쥴링 / 메모리 / 입출력장치
* 파일 시스템 관리